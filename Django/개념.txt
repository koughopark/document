어플리케이션 만들기
> python manage.py startapp main
메인 디렉토리 생성됨

장고에 사용해야 한다고 알려줘야 한다.
settings.py 에서 코드 추가
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'main',
]


manage.py는 스크립트인데, 사이트 관리를 도와주는 역할을 합니다. 이 스크립트로 다른 설치 작업 없이, 컴퓨터에서 웹 서버를 시작할 수 있습니다.

settings.py는 웹사이트 설정이 있는 파일입니다.

urls.py파일은 urlresolver가 사용하는 패턴 목록을 포함하고 있습니다.

class Post(models.Model):
models은 Post가 장고 모델임을 의미합니다. 이 코드 때문에 장고는 Post가 데이터베이스에 저장되어야 한다고 알게 됩니다.

python manage.py makemigrations blog
장고 모델에 (우리가 방금 만든!) 몇 가지 변화가 생겼다는 걸 알게 해줘야 한다.

장고는 데이터베이스에 지금 반영할 수 있도록 마이그레이션 파일(migration file)이라는 것을 준비해 두었다.
python manage.py migrate blog
실제 데이터베이스에 모델 추가를 반영.

admin.site.register(Post)
관리자 페이지에서 만든 모델을 보려면 모델을 등록해야 한다.

python manage.py createsuperuser
로그인하기 위해서는, 모든 권한을 가지는 슈퍼 사용자(superuser)를 생성해야 한다.

인터넷의 모든 페이지는 고유한 URL을 가지고 있어야 해요.
애플리케이션은 사용자가 URL을 입력하면 어떤 내용을 보여줘야 하는지 알고 있어요.
장고는 URLconf (URL configuration)를 사용합니다.
URLconf는 장고에서 URL과 일치하는 뷰를 찾기 위한 패턴들의 집합입니다.

관리자 URL
url(r'^admin/', admin.site.urls),

장고는 admin/로 시작하는 모든 URL을 view와 대조해 찾아낸다.

정규표현식(Regex)
^ : 문자열이 시작할 떄
$ : 문자열이 끝날 때
\d : 숫자
: 바로 앞에 나오는 항목이 계속 나올 때
() : 패턴의 부분을 저장할 때

^post/(\d+)/$

^post/ : url이(오른쪽부터) post/로 시작합니다.
(\d+) : 숫자(한 개 이상)가 있습니다. 이 숫자로 조회하고 싶은 게시글을 찾을 수 있어요.
/ : /뒤에 문자가 있습니다.
$ : url 마지막이 /로 끝납니다

mysite/urls.py파일을 깨끗한 상태로 유지하기 위해, blog 애플리케이션에서 메인 mysite/urls.py파일로 url들을 가져올 거에요.

먼저 #로 시작하는 줄을 삭제하고 main url('')로 blog.urls를 가져오는 행을 추가해 봅시다.

장고는 http://127.0.0.1:8000/ 로 들어오는 모든 접속 요청을 blog.urls로 전송해 추가 명령을 찾을 거예요.

from django.conf.urls import url
from . import views
장고의 메소드와 blog 애플리케이션에서 사용할 모든 views를 불러오고 있다.

name='post_list'는 URL에 이름을 붙인 것으로 뷰를 식별합니다
urlpatterns = [
    url(r'^$', views.post_list, name='post_list'),  # 이 패턴은 장고에게 누군가 웹사이트에 'http://127.0.0.1:8000/' 주소로 들어왔을 때 views.post_list를 보여준다
]

뷰(view) 는 애플리케이션의 "로직"을 넣는 곳이다.
뷰는 이전 장에서 만들었던 모델에서 필요한 정보를 받아와서 템플릿에 전달하는 역할을 한다.

post_list라는 함수(def) 만들어 요청(request)을 넘겨받아 render메서드를 호출합니다. 이 함수는 호출하여 받은(return) blog/post_list.html템플릿을 보여준다.

템플릿 파일에 모든 내용이 저장된다.

(왜 똑같은 blog디렉토리를 하나 더 만들어야하는지 궁금할 거에요. 나중에 알게 되겠지만, 나중에 폴더 구조가 복잡해 질 때 좀더 쉽게 찾기 위해 사용하는 관습적인 방법이랍니다)

각 HTML 페이지는 두 가지 요소, head와 body로 구분됩니다.
head 는 문서 정보를 가지고 있지만, 웹 페이지에서 보이지 않는 정보들을 담는 영역입니다.
body 란 웹 페이지에 직접적으로 보이는 내용이 들어갑니다. 웹 페이지의 내용은 모두 이 body태그안에 들어갑니다.
<head>는 브라우저에 페이지에 대한 설정들을 알려주고, <body>는 실제 페이지에 보여줄 내용을 알려줍니다.

<h1>A heading</h1> - 큰 제목
<h2>A sub-heading</h2> - 중 제목
<h3>A sub-sub-heading</h3> - 소 제목... <h6>레벨까지 사용할 수 있습니다.
<em>text</em> - 텍스트 기울기 (Italic)
<strong>text</strong> - 텍스트를 두껍게(Bold)
<br /> - 줄바꿈 (br은 스스로 닫히는 태그로 속성을 사용할 수 없습니다)
<a href="http://djangogirls.org">link</a> - 하이퍼링크 걸기
<ul><li>first item</li><li>second item</li></ul>- 목록 만들기
<div></div> - 페이지 섹션

 (test)라는 사용자가 작성한 모든 글을 찾고 싶다고 해볼게요. 이런 경우 Post.objects.all()에서 all대신, filter를 사용합니다.
모든 글들 중, 제목(title)에 'title'이라는 글자가 들어간 글들만을 뽑아내서 보고 싶다면?

command-line
>>> Post.objects.filter(title__contains='title')
[<Post: Sample title>, <Post: 4th title of post>]
title와 contains 사이에 있는 밑줄(_)이 2개(__)입니다. 장고 ORM은 필드 이름("title")과 연산자과 필터("contains")를 밑줄 2개를 사용해 구분합니다. 밑줄 1개만 입력한다면, FieldError: Cannot resolve keyword title_contains라는 오류가 뜰 거예요.

정렬
Post.objects.order_by('created_date')   # 오름차순
Post.objects.order_by('-created_date')  # 내림차순

쿼리셋 연결하기
쿼리셋들을 함께 연결(chaining)할 수 있어요.
command-line
>>> Post.objects.filter(published_date__lte=timezone.now()).order_by('published_date')
이 방법은 정말 강력해 복잡한 쿼리도 작성할 수 있게 해준답니다.
좋아요! 이제 다음 내용으로 넘어갈 때로군요! 다음 명령을 입력해, 쉘을 종료하세요. :
command-line
>>> exit()
$


뷰(view)는 모델과 템플릿을 연결하는 역할을 합니다. post_list를 뷰에서 보여주고 이를 템플릿에 전달하기 위해서는, 모델을 가져와야 합니다.
일반적으로 뷰가 템플릿에서 모델을 선택하도록 만들어야 합니다.
Post모델에서 블로그 글을 가져오기 위해서는 쿼리셋(QuerySet)이 필요합니다.


