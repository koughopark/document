[요약]

파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행됩니다. 그래서 임포트 내부 함수의 자동실행 방지를 위해 조건절 아래에서 실행되도록 한다.

__name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의 이름이 들어갑니다.

하지만 파이썬 인터프리터로 스크립트 파일을 직접 실행했을 때는 모듈의 이름이 아니라 '__main__'이 들어갑니다

어떤 스크립트 파일이든 파이썬 인터프리터가 최초로 실행한 스크립트 파일의 __name__에는 '__main__'이 들어갑니다. 이는 프로그램의 시작점(entry point)이라는 뜻입니다.

파이썬은 최초로 시작하는 스크립트 파일과 모듈의 차이가 없습니다. 어떤 스크립트 파일이든 시작점도 될 수 있고, 모듈도 될 수 있습니다. 그래서 __name__ 변수를 통해 현재 스크립트 파일이 시작점인지 모듈인지 판단합니다.

if __name__ == '__main__':처럼 __name__ 변수의 값이 '__main__'인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업입니다. 보통은 스크립트 파일이 모듈로 사용되는 것에 대비하여 이런 코드를 사용합니다.

참고 | 파이썬은 왜 프로그램의 시작점이 정해져 있지 않나요?
파이썬이 처음에 개발 될 당시에는 리눅스/유닉스에서 사용하는 스크립트 언어 기반이었기 때문에 프로그램의 시작점이 따로 정해져 있지 않았습니다. 보통 리눅스/유닉스의 스크립트 파일은 파일 한 개로 이루어진 경우가 많은데, 이 스크립트 파일 자체가 하나의 프로그램이다 보니 시작점이 따로 필요하지 않습니다. 하지만 C 언어나 자바같은 언어는 처음 만들어질 때부터 소스 파일을 여러 개 사용했기 때문에 여러 소스 파일의 함수들 중에서도 시작 함수(main)를 따로 정해 놓았습니다.

==============================================================================================================================================================================================



46.2 모듈과 시작점 알아보기
인터넷에 있는 파이썬 코드를 보다 보면 if __name__ == '__main__':으로 시작하는 부분을 자주 만나게 됩니다.

if __name__ == '__main__':
    코드
도대체 이 코드는 왜 사용하는 것일까요? 이 코드는 현재 스크립트 파일이 실행되는 상태를 파악하기 위해 사용합니다.

먼저 __name__부터 알아보겠습니다. 다음 내용을 프로젝트 폴더(C:\project) 안에 hello.py 파일로 저장하세요.

hello.py
print('hello 모듈 시작')
print('hello.py __name__:', __name__)    # __name__ 변수 출력
print('hello 모듈 끝')
그리고 다음 내용을 프로젝트 폴더(C:\project) 안에 main.py 파일로 저장한 뒤 실행해보세요.

main.py
import hello    # hello 모듈을 가져옴

print('main.py __name__:', __name__)    # __name__ 변수 출력
실행 결과
hello 모듈 시작
hello.py __name__: hello
hello 모듈 끝
main.py __name__: __main__
실행을 해보면 hello.py 파일과 main.py 파일의 __name__ 변수 값이 출력됩니다. 파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행됩니다. 따라서 hello 모듈을 가져오면 hello.py 안의 코드가 실행되며 __name__ 변수에는 'hello'이 들어있고, main.py의 __name__ 변수에는 '__main__'이 들어있습니다.

즉, __name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의 이름이 들어갑니다. 하지만 파이썬 인터프리터로 스크립트 파일을 직접 실행했을 때는 모듈의 이름이 아니라 '__main__'이 들어갑니다(참고로 __name__과 __main__을 헷갈리지 마세요. 같은 네 글자에 알파벳 모양이 비슷해서 헷갈리기 쉽습니다).

좀더 정확하게 알아보기 위해 콘솔(터미널, 명령 프롬프트)에서 python으로 main.py 파일을 실행해봅니다(리눅스, macOS에서는 python3 사용).

C:₩project>python main.py
hello 모듈 시작
hello.py __name__: hello
hello 모듈 끝
main.py __name__: __main__
python main.py와 같이 파이썬으로 스크립트 파일을 직접 실행했습니다. 여기서도 hello.py 파일의 __name__ 변수에는 'hello' 그리고 main.py 파일의 __name__ 변수에는 '__main__'이 들어있습니다. 하지만 다음과 같이 python으로 hello.py 파일을 실행해보면 결과가 조금 달라집니다.

C:₩project>python hello.py
hello 모듈 시작
hello.py __name__: __main__
hello 모듈 끝
hello.py 파일의 __name__ 변수에는 'hello'가 아니라 '__main__'이 들어있습니다. 즉, 어떤 스크립트 파일이든 파이썬 인터프리터가 최초로 실행한 스크립트 파일의 __name__에는 '__main__'이 들어갑니다. 이는 프로그램의 시작점(entry point)이라는 뜻입니다.

파이썬은 최초로 시작하는 스크립트 파일과 모듈의 차이가 없습니다. 어떤 스크립트 파일이든 시작점도 될 수 있고, 모듈도 될 수 있습니다. 그래서 __name__ 변수를 통해 현재 스크립트 파일이 시작점인지 모듈인지 판단합니다.
if __name__ == '__main__':처럼 __name__ 변수의 값이 '__main__'인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업입니다. 보통은 스크립트 파일이 모듈로 사용되는 것에 대비하여 이런 코드를 사용합니다.
그럼 스크립트 파일을 그대로 실행할 수도 있고, 모듈로도 사용할 수 있는 코드를 만들어보겠습니다. 다음 내용을 프로젝트 폴더(C:\project) 안에 calc.py 파일로 저장한 뒤 실행해보세요.

calc.py
def add(a, b):
    return a + b

def mul(a, b):
    return a * b

if __name__ == '__main__':    # 프로그램의 시작점일 때만 아래 코드 실행
    print(add(10, 20))
    print(mul(10, 20))
실행 결과
30
200
C:₩project>python calc.py
30
200
IDLE에서 실행하거나 python calc.py와 같이 파이썬 인터프리터로 실행하면 10, 20의 합과 곱이 출력됩니다. 즉, 프로그램의 시작점일 때는 if __name__ == '__main__': 아래의 코드가 실행됩니다.

그럼 calc.py를 모듈로 사용하면 어떻게 될까요? 다음과 같이 import로 calc를 가져와봅니다.

>>> import calc
>>>
모듈로 가져왔을 때는 아무것도 출력되지 않습니다. 왜냐하면 __name__ 변수의 값이 '__main__'일 때만 10, 20의 합과 곱을 출력하도록 만들었기 때문입니다. 즉, 스크립트 파일을 모듈로 사용할 때는 calc.add, calc.mul처럼 함수만 사용하는 것이 목적이므로 10, 20의 합과 곱을 출력하는 코드는 필요가 없습니다.

>>> calc.add(50, 60)
110
>>> calc.mul(50, 60)
3000
참고 | 파이썬은 왜 프로그램의 시작점이 정해져 있지 않나요?
파이썬이 처음에 개발 될 당시에는 리눅스/유닉스에서 사용하는 스크립트 언어 기반이었기 때문에 프로그램의 시작점이 따로 정해져 있지 않았습니다. 보통 리눅스/유닉스의 스크립트 파일은 파일 한 개로 이루어진 경우가 많은데, 이 스크립트 파일 자체가 하나의 프로그램이다 보니 시작점이 따로 필요하지 않습니다. 하지만 C 언어나 자바같은 언어는 처음 만들어질 때부터 소스 파일을 여러 개 사용했기 때문에 여러 소스 파일의 함수들 중에서도 시작 함수(main)를 따로 정해 놓았습니다.


========================================================================================================================================================================================

if __name__ == "__main__": 의 의미
이번에는 mod1.py 파일에 다음과 같이 추가해 보자.

# mod1.py
def sum(a, b):
    return a+b

def safe_sum(a, b):
    if type(a) != type(b):
        print("더할수 있는 것이 아닙니다.")
        return
    else:
        result = sum(a, b)
    return result

print(safe_sum('a', 1))
print(safe_sum(1, 4))
print(sum(10, 10.4))
위와 같은 mod1.py 파일을 에디터로 작성해서 C:\doit이라는 디렉터리에 저장했다면 다음처럼 실행할 수 있다.

C:\doit>python mod1.py
더할 수 있는 것이 아닙니다.
None
5
20.4
결과값은 위의 예처럼 출력될 것이다. 그런데 이 mod1.py 파일의 sum과 safe_sum 함수를 사용하기 위해 mod1.py 파일을 import하면 문제가 생긴다.

명령 프롬프트 창을 열고 다음을 따라 해보자.

C:\WINDOWS> cd C:\doit
C:\doit>python
>>> import mod1
더할 수 있는 것이 아닙니다.
None
5
20.4
엉뚱하게도 import mod1을 수행하는 순간 mod1.py가 실행이 되어 결과값을 출력한다. 우리는 단지 mod1.py 파일의 sum과 safe_sum 함수만 사용하려고 했는데 말이다. 이러한 문제를 방지하려면 다음처럼 하면 된다.

if __name__ == "__main__":
    print(safe_sum('a', 1))
    print(safe_sum(1, 4))
    print(sum(10, 10.4))
if __name__ == "__main__"을 사용하면 C:\doit>python mod1.py처럼 직접 이 파일을 실행시켰을 때는 __name__ == "__main__"이 참이 되어 if문 다음 문장들이 수행된다. 반대로 대화형 인터프리터나 다른 파일에서 이 모듈을 불러서 사용할 때는 __name__ == "__main__"이 거짓이 되어 if문 다음 문장들이 수행되지 않는다.

파이썬 모듈을 만든 다음 그 모듈을 테스트하기 위해 보통 위와 같은 방법을 사용하는데, 실제로 그런지 대화형 인터프리터를 열고 실행해 보자.

>>> import mod1
>>>
mod1.py 파일의 마지막 부분을 위와 같이 고친 다음에는 아무런 결과값도 출력되지 않는 것을 볼 수 있다.

알아두기

파이썬의 __name__ 변수는 파이썬이 내부적으로 사용하는 특별한 변수명이다. 만약 C:\doit>python mod1.py처럼 직접 mod1.py 파일을 실행시킬 경우 mod1.py의 __name__ 변수에는 __main__ 이라는 값이 저장된다. 하지만 파이썬 쉘이나 다른 파이썬 모듈에서 mod1을 import 할 경우에는 mod1.py의 __name__ 변수에는 "mod1"이라는 mod1.py의 모듈이름 값이 저장된다.